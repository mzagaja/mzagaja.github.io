---
layout: post
title: Why Low and No Code is Expensive
tags:
  - Software
---
Lately no and low code solutions have grown in popularity. These software packages take work traditionally performed by writing software code and enable it to happen in graphical user interfaces that are accessible to more users. This can eliminate the need to learn to code to get tasks done, but come with their own costs and trade-offs. No code might seem like a bargain at first, but often turns out to be a bad deal.

There are two foundations of software engineering that no-code and low-code platforms lack: version control and automated testing. Modern software is developed using version control so you have a history of who changed code, how they changed it, and why they changed it. Automated testing validates the functionality of your work. If you make a change, the automated tests confirm it does not impact the other parts of your program. Low and no code solutions have to be click tested. Furthermore the artifacts created by users are less detailed than version controlled code. As your no and low code solution grows in complexity, its cost to build, maintain, and debug will start to exceed coded solutions.

Integrating with no and low code platforms is more challenging that with code based platforms. Low code solutions like AirTable do not **version their APIs** nor do they warn the user that an action they take can impact coded integrations. Even more challenging is integration with standard spreadsheets like Excel that have no validations to guarantee the format of the cells as a spreadsheet changes. The freedom provided by the graphical user interface of the tool shifts complexity onto software developers that might attempt to integrate with it. There is almost never an option to give the user of the tool guardrails that prevent them from doing dangerous things. If you want to integrate low or no code with code, you are going to end up paying a lot extra. 

Debugging low and no code platforms is more challenging than code based platforms. In software code the logic of your methods and approach are exposed in an ordered and easy to review manner. No and low code platforms often obscure the methods behind the user interface. This is most apparent in spreadsheet applications which require double clicking each individual cell to view the formula behind the value, or whether it’s a formula at all. Have you changed one formula, or five? You will never know unless you meticulously review each cell. The time and money you saved by using no and low code evaporates when you need to audit your work.

No and low code solutions are often less portable than their coded cousins. They lock you in. If a no or low code tool shuts down or you can no longer pay for them, there is not another way to fully see and use the functionality of what you had. You might be able to export your data in another format, but that format will not know everything about what you did in the tool. Running legacy code is not always easy, but it is at least doable. Legacy no-code solutions are often just lost. I have spent much of my professional career rewriting and reverse engineering low and no code tool functionality to fix an application after the tool has gone kaput. 

Collaborating and sharing techniques is harder with low and no code. When I develop a useful approach in code I can write an example code snippet with some comments and post it to GitHub or StackOverflow to be re-used by others. This communication is high signal. In many cases code can be copied and modified slightly to function as intended. If I find an interesting approach in a low or no code tool I need to write out step-by-step instructions that may or may not be clear to the user, or make a screencast. The input and output takes longer on both ends. Everyone does more work and gets less done.

Being able to harness the power that coders wield in easy to use interfaces is seductive. Doing a join in Airtable, creating a chart in Tableau, or building your first Zap can create that same ping of joy I felt when I created my first Rails app. For first drafts, prototypes, and sketching these tools can be powerful. However they have a long way to go before they can be as reliable and easy to work with as their coded cousins. Today’s no and low code tools are high interest loans: a way to pay less now so you can pay more later.